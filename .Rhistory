# Цвет сопоставлен с непрерывным столбцом
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
geom_point(mapping = aes(color = temp))+
labs(title = "Color mapped to continuous column")
# Цвет сопоставлен с дискретным столбцом
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
geom_point(mapping = aes(color = gender))+
labs(title = "Color mapped to discrete column")
# столбчатая диаграмма, заливка сопоставлена с дискретным столбцом, цвет - со статическим значением
ggplot(data = linelist, mapping = aes(x = hospital))+
geom_bar(mapping = aes(fill = gender), color = "yellow")+
labs(title = "Fill mapped to discrete column, static color")
# Исходная ситуация - без настройки шкалы
ggplot(data = linelist)+
geom_bar(mapping = aes(x = outcome, fill = gender))+
labs(title = "Baseline - no scale adjustments")
# НАСТРОЙКА ШКАЛЫ
ggplot(data = linelist)+
geom_bar(mapping = aes(x = outcome, fill = gender), color = "black")+
theme_minimal()+                   # упростить фон
scale_y_continuous(                # непрерывная шкала для оси y (количество)
expand = c(0,0),                 # без наращивания
breaks = seq(from = 0,
to = 3000,
by = 500))+
scale_x_discrete(                   # дискретная шкала для оси x (пол)
expand = c(0,0),                  # без наращивания
drop = FALSE,                     # показать все уровни факторов (даже если их нет в данных)
na.translate = FALSE,             # удалить исходы NA из графика
labels = c("Died", "Recovered"))+ # Изменение отображения значений
scale_fill_manual(                  # Вручную задать заливку (внутренний цвет столбика)
values = c("m" = "violetred",     # референсные значения в данных для присвоения цветов
"f" = "aquamarine"),
labels = c("m" = "Male",          # Изменить метки в легенде (во избежание ошибок используйте присваивание "=")
"f" = "Female",
"Missing"),
name = "Gender",                  # заголовок легенды
na.value = "grey"                 # назначение цвета для отсутствующего значенияs
)+
labs(title = "Adjustment of scales") # Настройка заголовка легенды заливки
# Исходная ситуация - без настройки шкалы
ggplot(data = linelist)+
geom_bar(mapping = aes(x = outcome, fill = gender))+
labs(title = "Baseline - no scale adjustments")
#
ggplot(data = linelist)+
geom_bar(mapping = aes(x = outcome, fill = gender))+
scale_y_continuous(
breaks = seq(
from = 0,
to = 3000,
by = 100)
)+
labs(title = "Adjusted y-axis breaks")
# Исходные пропорции оси y
#############################
linelist %>%                                   # начать с построчного списка
group_by(hospital) %>%                       # сгруппировать данные по больницамl
summarise(                                   # создать сводные столбцы
n = n(),                                     # общее количество строк в группе
deaths = sum(outcome == "Death", na.rm=T),   # количество смертельных исходов в группе
prop_death = deaths/n) %>%                   # доля смертельных исходов в группе
ggplot(                                      # начать построение графика
mapping = aes(
x = hospital,
y = prop_death))+
geom_col()+
theme_minimal()+
labs(title = "Display y-axis original proportions")
# Отображение пропорций оси y в виде процентов
########################################
linelist %>%
group_by(hospital) %>%
summarise(
n = n(),
deaths = sum(outcome == "Death", na.rm=T),
prop_death = deaths/n) %>%
ggplot(
mapping = aes(
x = hospital,
y = prop_death))+
geom_col()+
theme_minimal()+
labs(title = "Display y-axis as percents (%)")+
scale_y_continuous(
labels = scales::percent                    # отображать пропорции в виде процентов
)
plot_data <- data.frame(
region = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),
cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)
)
plot_data
# Исходная ось y
preparedness_plot <- ggplot(data = plot_data,
mapping = aes(
x = preparedness_index,
y = cases_cumulative))+
geom_point(size = 2)+            # точки для каждого региона
geom_text(
mapping = aes(label = region),
vjust = 1.5)+                  # добавление текстовых меток
theme_minimal()
preparedness_plot                  # печать исходного графика
# печать с преобразованием оси y
preparedness_plot+                   # начать с графика, сохраненного выше
scale_y_continuous(trans = "log2") # добавить преобразование для оси y
case_source_relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>%
select(source_age, target_age)
trans_matrix <- ggplot(
data = case_source_relationships,
mapping = aes(x = source_age, y = target_age))+
stat_density2d(
geom = "raster",
mapping = aes(fill = after_stat(density)),
contour = FALSE)+
theme_minimal()
trans_matrix
trans_matrix + scale_fill_viridis_c(option = "plasma")
trans_matrix +
scale_fill_gradient(     # Двусторонняя градиентная шкала
low = "aquamarine",    # низкое значение
high = "purple",       # высокое значение
na.value = "grey",     # значение для NA
name = "Density")+     # Заголовок легенды
labs(title = "Manually specify high/low colors")
# 3+ цвета в шкале
trans_matrix +
scale_fill_gradientn(    # 3-цветная шкала (низкий/средний/высокий уровень)
colors = c("blue", "yellow","red") # предоставить цвета в векторе
)+
labs(title = "3-color scale")
# Использование функции rescale() для изменения расположения цветов по шкале
trans_matrix +
scale_fill_gradientn(    # задать любое количество цветов
colors = c("blue", "yellow","red", "black"),
values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) #позиции цветов изменяются в диапазоне от 0 до 1
)+
labs(title = "Colors not evenly positioned")
# использование ограничений для отсечения значений, получающих цвет заливки
trans_matrix +
scale_fill_gradientn(
colors = c("blue", "yellow","red"),
limits = c(0, 0.0002))+
labs(title = "Restrict value limits, resulting in grey space")
symp_plot <- linelist %>%                                         # начать с построчного списка
select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # выбрать столбцы
pivot_longer(                                                  # повернуть вдлину
cols = -case_id,
names_to = "symptom_name",
values_to = "symptom_is_present") %>%
mutate(                                                        # заменить отсутствующие значения
symptom_is_present = replace_na(symptom_is_present, "unknown")) %>%
ggplot(                                                        # начать ggplot!
mapping = aes(x = symptom_name, fill = symptom_is_present))+
geom_bar(position = "fill", col = "black") +
theme_classic() +
theme(legend.position = "bottom")+
labs(
x = "Symptom",
y = "Symptom status (proportion)"
)
symp_plot  # печать с цветами по умолчанию
#################################
# печать с заданными вручную цветами
symp_plot +
scale_fill_manual(
values = c("yes" = "black",         # четко определить цвета
"no" = "white",
"unknown" = "grey"),
breaks = c("yes", "no", "unknown"), # правильно упорядочить факторы
name = ""                           # задать легенду без заголовка
)
#################################
# печать дискретными цветами viridis
symp_plot +
scale_fill_viridis_d(
breaks = c("yes", "no", "unknown"),
name = ""
)
ggplot(
data = linelist %>% drop_na(age_cat5),                         # удалить строки, в которых отсутствует age_cat5
mapping = aes(x = fct_relevel(age_cat5, "5-9", after = 1))) +  # заново задать уровень фактора
geom_bar() +
labs(x = "Age group", y = "Number of hospitalisations",
title = "Total hospitalisations by age group") +
theme_minimal()
case_source_relationships %>%
ggplot(aes(x = source_age, y = target_age))+
stat_density2d()+
geom_point()+
theme_minimal()+
labs(title = "stat_density2d() + geom_point()")
case_source_relationships %>%
ggplot(aes(x = source_age, y = target_age))+
stat_density2d_filled()+
theme_minimal()+
labs(title = "stat_density2d_filled()")
# Установка/загрузка ggExtra
pacman::p_load(ggExtra)
# Базовая диаграмма рассеивания веса и возраста
scatter_plot <- ggplot(data = linelist)+
geom_point(mapping = aes(y = wt_kg, x = age)) +
labs(title = "Scatter plot of weight and age")
# с гистограммами
ggMarginal(
scatter_plot,                     # добавить предельные гистограммы
type = "histogram",               # указать гистограммы
fill = "lightblue",               # заливка столбика
xparams = list(binwidth = 10),    # другие параметры для предельных значений по оси x
yparams = list(binwidth = 5))     # другие параметры для предельных значений по оси у
# График рассеивания, окрашенный по исходам
# Столбец исходов назначается цветом в ggplot. Значение groupFill в ggMarginal установлено как TRUE.
scatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+
geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +
labs(title = "Scatter plot of weight and age")+
theme(legend.position = "bottom")
ggMarginal(scatter_plot_color, type = "density", groupFill = TRUE)
# с коробчатой диаграммой
ggMarginal(
scatter_plot,
margins = "x",      # показывать только предельный график по оси x
type = "boxplot")
pacman::p_load(ggrepel)
linelist %>%                                               # начать с построчного списка
group_by(hospital) %>%                                   # сгруппировать по больницам
summarise(                                               # сформировать новый набор данных с сводными значениями по каждой больнице
n_cases = n(),                                           # количество случаев на одну больницу
delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # средняя задержка по больнице
) %>%
ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # передать датафрейм в ggplot
geom_point(size = 2)+                                    # добавить точки
geom_label_repel(                                        # добавить метки точек
mapping = aes(
label = stringr::str_glue(
"{hospital}\n{n_cases} cases, {delay_mean} days")  # как отображаются метки
),
size = 3,                                              # размер текста в метках
min.segment.length = 0)+                               # показать все сегменты линии
labs(                                                    # добавить метки осей
title = "Mean delay to admission, by hospital",
x = "Number of cases",
y = "Mean delay (days)")
ggplot()+
# Все точки выделены серым цветом
geom_point(
data = linelist,                                   # все данные, представленные в этом слое
mapping = aes(x = ht_cm, y = wt_kg),
color = "grey",
alpha = 0.5)+                                              # серый и полупрозрачный
# Few points in black
geom_point(
data = linelist %>% filter(days_onset_hosp > 15),  # фильтрованные данные, поступающие в этот слой
mapping = aes(x = ht_cm, y = wt_kg),
alpha = 1)+                                                # по умолчанию черный и не прозрачный
# point labels for few points
geom_label_repel(
data = linelist %>% filter(days_onset_hosp > 15),  # отфильтровать данные для меток
mapping = aes(
x = ht_cm,
y = wt_kg,
fill = outcome,                                          # обозначение цвета метками в зависимости от исхода
label = stringr::str_glue("Delay: {days_onset_hosp}d")), # метка, созданная с помощью функции str_glue()
min.segment.length = 0) +                                  # показать сегменты линий для всех
# убрать букву "a" из внутренних полей легенды
guides(fill = guide_legend(override.aes = aes(color = NA)))+
# метки осей
labs(
title = "Cases with long delay to admission",
y = "weight (kg)",
x = "height(cm)")
# построить эпидемическую кривую по дате начала заболевания, если это возможно
ggplot(linelist, aes(x = date_onset)) +
geom_histogram(binwidth = 7) +
scale_x_date(
# 1 разрыв каждый 1 месяц
date_breaks = "1 months",
# На метках должен отображаться месяц, а затем дата
date_labels = "%b %d"
) +
theme_classic()
ggplot(linelist, aes(x = date_onset)) +
geom_histogram(binwidth = 7) +
scale_x_date(
labels = scales::label_date_short()  # автоматически эффективные метки даты
)+
theme_classic()
# загрузка gghighlight
library(gghighlight)
# заменить значения NA на неизвестные в переменной исхода
linelist <- linelist %>%
mutate(outcome = replace_na(outcome, "Unknown"))
# построить гистограмму всех случаев по возрасту
ggplot(
data = linelist,
mapping = aes(x = age_years, fill = outcome)) +
geom_histogram() +
gghighlight::gghighlight(outcome == "Death")     # выделить случаи, когда пациент умер
# построить гистограмму всех случаев по возрасту
linelist %>%
count(week = lubridate::floor_date(date_hospitalisation, "week"),
hospital) %>%
ggplot()+
geom_line(aes(x = week, y = n, color = hospital))+
theme_minimal()+
gghighlight::gghighlight() +                      # выделить случаи, когда пациент умер
facet_wrap(~hospital)                              # создавать фасеты по исходам
pacman::p_load(
tidyverse,      # работа с данными и их визуализация
cowplot,        # объединение графиков
patchwork       # объединение графиков
)
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds"))
# столбчатая диаграмма общего количества случаев по районам
p1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +
geom_bar(stat = "identity") +
labs(
x = "District",
y = "Total number of cases",
title = "Total malaria cases by district"
) +
theme_minimal()
# эпидемическая кривая во времени
p2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
geom_col(width = 1) +
labs(
x = "Date of data submission",
y =  "number of cases"
) +
theme_minimal()
cowplot::plot_grid(p1, p2,
# 1 столбец и две строки - уложенные друг на друга
ncol = 1,
nrow = 2,
# верхний график на 2/3 выше второго
rel_heights = c(2, 3))
p1 <- linelist %>%
mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>%
count(hospital, outcome) %>%
ggplot()+
geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
coord_flip()+
theme_minimal()+
labs(title = "Cases by outcome")
p2 <- linelist %>%
mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>%
count(hospital, age_cat) %>%
ggplot()+
geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
coord_flip()+
theme_minimal()+
theme(axis.text.y = element_blank())+
labs(title = "Cases by age")
cowplot::plot_grid(p1, p2, rel_widths = c(0.3))
# Определить график 1 без легенды
p1 <- linelist %>%
mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>%
count(hospital, outcome) %>%
ggplot()+
geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
coord_flip()+
theme_minimal()+
theme(legend.position = "none")+
labs(title = "Cases by outcome")
# Определить график 2 без легенды
p2 <- linelist %>%
mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>%
count(hospital, age_cat) %>%
ggplot()+
geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
coord_flip()+
theme_minimal()+
theme(
legend.position = "none",
axis.text.y = element_blank(),
axis.title.y = element_blank()
)+
labs(title = "Cases by age")
# извлечение легенды из гр1 (из гр1 + легенда)
leg_p1 <- cowplot::get_legend(p1 +
theme(legend.position = "right",        # извлечение вертикальной легенды
legend.justification = c(0,0.5))+ # легенды должны быть выровнены
labs(fill = "Outcome"))                 # заголовок легенды
# извлечение легенды из гр2 (из гр2 + легенда)
leg_p2 <- cowplot::get_legend(p2 +
theme(legend.position = "right",         # извлечение вертикальной легенды
legend.justification = c(0,0.5))+  # легенды должны быть выровнены
labs(fill = "Age Category"))             # заголовок легенды
# создание пустого графика для выравнивания легенды
#blank_p <- patchwork::plot_spacer() + theme_void()
# создание панелей легенд, которые могут располагаться одна на другой (или использовать разделитель, о котором говорилось выше)
legends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))
# объединение двух графиков и панели объединенных легенд
combined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))
combined  # печать
# Определить основной график
main_plot <- ggplot(data = linelist)+
geom_histogram(aes(x = date_onset, fill = hospital))+
scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
theme_half_open()+
theme(legend.position = "bottom")+
labs(title = "Epidemic curve and outcomes by hospital")
# Определить вставной график
inset_plot <- linelist %>%
mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>%
count(hospital, outcome) %>%
ggplot()+
geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
coord_flip()+
theme_minimal()+
theme(legend.position = "none",
axis.title.y = element_blank())+
labs(title = "Cases by outcome")
# Объединить основной график и вставной
cowplot::ggdraw(main_plot)+
draw_plot(inset_plot,
x = .6, y = .55,    #x = .07, y = .65,
width = .4, height = .4)
pacman::p_load(cowplot)            # загрузка/установка cowplot
p1 <- linelist %>%                 # сохранить график как объект
count(
epiweek = lubridate::floor_date(date_onset, "week")) %>%
ggplot()+
geom_area(aes(x = epiweek, y = n), fill = "grey")+
scale_x_date(
date_breaks = "month",
date_labels = "%b")+
theme_cowplot()+
labs(
y = "Weekly cases"
)
p1                                      # просмотр графика
p2 <- linelist %>%         # сохранить график как объект
group_by(
epiweek = lubridate::floor_date(date_onset, "week")) %>%
summarise(
n = n(),
pct_death = 100*sum(outcome == "Death", na.rm=T) / n) %>%
ggplot(aes(x = epiweek, y = pct_death))+
geom_line()+
scale_x_date(
date_breaks = "month",
date_labels = "%b")+
scale_y_continuous(
position = "right")+
theme_cowplot()+
labs(
x = "Epiweek of symptom onset",
y = "Weekly percent of deaths",
title = "Weekly case incidence and percent deaths"
)
p2     # просмотр графика
aligned_plots <- cowplot::align_plots(p1, p2, align="hv", axis="tblr")         # выровнять два графика и сохранить их в виде списка
aligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # наложить их друг на друга и сохранить визуальный график
aligned_plotted                                                                # печать наложенных друг на друга графиков
pacman::p_load(
tidyverse,      # includes ggplot2 and other
rio,            # import/export
here,           # file locator
stringr,        # working with characters
scales,         # transform numbers
ggrepel,        # smartly-placed labels
gghighlight,    # highlight one part of plot
RColorBrewer    # color scales
)
pacman::p_load(
tidyverse, # включает в себя ggplot2 и другие
rio, # импорт/экспорт
here, # локатор файлов
stringr, # работа с символами
scales, # преобразование чисел
ggrepel, # грамотно расставленные метки
gghighlight, # выделение одной части графика
RColorBrewer, # цветовые шкалы
)
pacman::p_load(
tidyverse, # включает в себя ggplot2 и другие
rio, # импорт/экспорт
here, # локатор файлов
stringr, # работа с символами
scales, # преобразование чисел
ggrepel, # грамотно расставленные метки
gghighlight, # выделение одной части графика
RColorBrewer # цветовые шкалы
)
babelquarto::render_book()
babelquarto::render_book()
# Translate chapter page
chapter_list = c("editorial_style.qmd", "data_used.qmd", "basics.qmd", "transition_to_R.qmd", "packages_suggested.qmd", "r_projects.qmd", "importing.qmd", #"cleaning.qmd",
"dates.qmd", #"characters_strings.qmd",
"factors.qmd", "pivoting.qmd", "grouping.qmd", "joining_matching.qmd", "deduplication.qmd", "iteration.qmd", "tables_descriptive.qmd", "stat_tests.qmd", "regression.qmd", "missing_data.qmd",
"standardization.qmd", "moving_average.qmd", "time_series.qmd", "epidemic_models.qmd", "contact_tracing.qmd", "survey_analysis.qmd", "survival_analysis.qmd", "gis.qmd", "tables_presentation.qmd", "ggplot_basics.qmd", "ggplot_tips.qmd", "epicurves.qmd", "age_pyramid.qmd", "heatmaps.qmd", "diagrams.qmd", "combination_analysis.qmd", "transmission_chains.qmd", "phylogenetic_trees.qmd", "interactive_plots.qmd", "rmarkdown.qmd", "reportfactory.qmd", "flexdashboard.qmd", "shiny_basics.qmd", "writing_functions.qmd", "directories.qmd", "collaboration.qmd", "errors.qmd", "help.qmd", "network_drives.qmd", "data_table.qmd")
chapter_list
as_data_frame(chapter_list)
print(as_data_frame(chapter_list), n = 100)
# Translate chapter page
chapter_list = c("editorial_style.qmd", "data_used.qmd", "basics.qmd", "transition_to_R.qmd", "packages_suggested.qmd", "r_projects.qmd", "importing.qmd", "cleaning.qmd",
"dates.qmd", "characters_strings.qmd",
"factors.qmd", "pivoting.qmd", "grouping.qmd", "joining_matching.qmd", "deduplication.qmd", "iteration.qmd", "tables_descriptive.qmd", "stat_tests.qmd", "regression.qmd", "missing_data.qmd",
"standardization.qmd", "moving_average.qmd", "time_series.qmd", "epidemic_models.qmd", "contact_tracing.qmd", "survey_analysis.qmd", "survival_analysis.qmd", "gis.qmd", "tables_presentation.qmd", "ggplot_basics.qmd", "ggplot_tips.qmd", "epicurves.qmd", "age_pyramid.qmd", "heatmaps.qmd", "diagrams.qmd", "combination_analysis.qmd", "transmission_chains.qmd", "phylogenetic_trees.qmd", "interactive_plots.qmd", "rmarkdown.qmd", "reportfactory.qmd", "flexdashboard.qmd", "shiny_basics.qmd", "writing_functions.qmd", "directories.qmd", "collaboration.qmd", "errors.qmd", "help.qmd", "network_drives.qmd", "data_table.qmd")
print(as_data_frame(chapter_list), n = 100)
chapter_list
babelquarto::render_book()
chapter_list
chapter_list
babelquarto::render_book()
babelquarto::render_book()
